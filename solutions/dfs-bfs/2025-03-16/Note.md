# DFSì™€ BFS íƒìƒ‰ ê²°ê³¼ ì¶œë ¥
ðŸ‘‰ðŸ»[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/1260)

## ë¬¸ì œ ì„¤ëª…
ê·¸ëž˜í”„ë¥¼ DFS(ê¹Šì´ ìš°ì„  íƒìƒ‰)ì™€ BFS(ë„ˆë¹„ ìš°ì„  íƒìƒ‰)ë¡œ íƒìƒ‰í•œ ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ëž¨ì„ ìž‘ì„±í•œë‹¤.
- ë°©ë¬¸í•  ìˆ˜ ìžˆëŠ” ì •ì ì´ ì—¬ëŸ¬ ê°œì¸ ê²½ìš°ì—ëŠ” **ì •ì  ë²ˆí˜¸ê°€ ìž‘ì€ ê²ƒë¶€í„° ë¨¼ì € ë°©ë¬¸**í•œë‹¤.
- ë” ì´ìƒ ë°©ë¬¸í•  ìˆ˜ ìžˆëŠ” ì •ì ì´ ì—†ëŠ” ê²½ìš° íƒìƒ‰ì„ ì¢…ë£Œí•œë‹¤.
- ì •ì  ë²ˆí˜¸ëŠ” 1ë²ˆë¶€í„° Në²ˆê¹Œì§€ ì£¼ì–´ì§„ë‹¤.

## ìž…ë ¥ í˜•ì‹
1. ì²«ì§¸ ì¤„ì— ì •ì ì˜ ê°œìˆ˜ **N(1 â‰¤ N â‰¤ 1,000)**, ê°„ì„ ì˜ ê°œìˆ˜ **M(1 â‰¤ M â‰¤ 10,000)**, íƒìƒ‰ì„ ì‹œìž‘í•  ì •ì ì˜ ë²ˆí˜¸ **V**ê°€ ì£¼ì–´ì§„ë‹¤.
2. ë‹¤ìŒ Mê°œì˜ ì¤„ì—ëŠ” ê°„ì„ ì´ ì—°ê²°í•˜ëŠ” ë‘ ì •ì ì˜ ë²ˆí˜¸ê°€ ì£¼ì–´ì§„ë‹¤.
3. ìž…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§€ëŠ” ê°„ì„ ì€ **ì–‘ë°©í–¥**ì´ë‹¤.

## ì¶œë ¥ í˜•ì‹
1. ì²«ì§¸ ì¤„ì— **DFS íƒìƒ‰ ê²°ê³¼**ë¥¼ ì¶œë ¥í•œë‹¤.
2. ë‘˜ì§¸ ì¤„ì— **BFS íƒìƒ‰ ê²°ê³¼**ë¥¼ ì¶œë ¥í•œë‹¤.
3. ì •ì  ë°©ë¬¸ ìˆœì„œëŠ” ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•œë‹¤.

## ì˜ˆì œ ìž…ë ¥ê³¼ ì¶œë ¥

### ì˜ˆì œ ìž…ë ¥ 1
```
4 5 1
1 2
1 3
1 4
2 4
3 4
```

### ì˜ˆì œ ì¶œë ¥ 1
```
1 2 4 3
1 2 3 4
```

### ì˜ˆì œ ìž…ë ¥ 2
```
5 5 3
5 4
5 2
1 2
3 4
3 1
```

### ì˜ˆì œ ì¶œë ¥ 2
```
3 1 2 5 4
3 1 4 2 5
```

### ì˜ˆì œ ìž…ë ¥ 3
```
1000 1 1000
999 1000
```

### ì˜ˆì œ ì¶œë ¥ 3
```
1000 999
1000 999
```

## ì½”ë“œ êµ¬í˜„
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strings"
)

var reader = bufio.NewReader(os.Stdin)
var writer = bufio.NewWriter(os.Stdout)

func DFS(v int, graph [][]int) []int {
	res := make([]int, 0)
	stack := make([]int, 0)
	stack = append(stack, v)
	check := make(map[int]struct{})

	for len(stack) > 0 {
		node := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if _, ok := check[node]; ok {
			continue
		}
		check[node] = struct{}{}

		for i := len(graph[node]) - 1; i >= 0; i-- {
			next := graph[node][i]
			if _, ok := check[next]; !ok {
				stack = append(stack, next)
			}
		}
		res = append(res, node)
	}
	return res
}

func BFS(v int, graph [][]int) []int {
	res := make([]int, 0)
	queue := make([]int, 0)
	queue = append(queue, v)
	check := make(map[int]struct{})
	check[v] = struct{}{}

	for len(queue) > 0 {
		node := queue[0]
		for i := 0; i < len(graph[node]); i++ {
			if _, ok := check[graph[node][i]]; !ok {
				check[graph[node][i]] = struct{}{}
				queue = append(queue, graph[node][i])
			}
		}
		res = append(res, node)
		queue = queue[1:]
	}
	return res
}

func main() {
	defer writer.Flush()
	var n, m, v int
	fmt.Fscan(reader, &n, &m, &v)
	graph := make([][]int, n+1)

	for i := 0; i < m; i++ {
		var a, b int
		fmt.Fscan(reader, &a, &b)
		graph[a] = append(graph[a], b)
		graph[b] = append(graph[b], a)
	}

	for i := 0; i < len(graph); i++ {
		sort.Ints(graph[i])
	}

	fmt.Fprintln(writer, strings.Trim(fmt.Sprint(DFS(v, graph)), "[]"))
	fmt.Fprintln(writer, strings.Trim(fmt.Sprint(BFS(v, graph)), "[]"))
}
```

## í•´ê²° ë°©ë²•
1. **ê·¸ëž˜í”„ ì €ìž¥**:
   - ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ê·¸ëž˜í”„ë¥¼ ì €ìž¥í•œë‹¤.
   - ì–‘ë°©í–¥ ê°„ì„ ì´ë¯€ë¡œ `graph[a]`ì™€ `graph[b]`ì— ê°ê° ê°’ì„ ì¶”ê°€í•œë‹¤.
   - ë°©ë¬¸í•  ìˆ˜ ìžˆëŠ” ë…¸ë“œë¥¼ **ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬**í•˜ì—¬ ìž‘ì€ ë²ˆí˜¸ë¶€í„° ë°©ë¬¸í•˜ë„ë¡ í•œë‹¤.

2. **DFS (ê¹Šì´ ìš°ì„  íƒìƒ‰)**
   - ìŠ¤íƒì„ í™œìš©í•˜ì—¬ êµ¬í˜„í•œë‹¤.
   - ë°©ë¬¸í•œ ì •ì ì„ ì²´í¬í•˜ê¸° ìœ„í•´ `map[int]struct{}`ì„ ì‚¬ìš©í•œë‹¤.
   - ìŠ¤íƒì—ì„œ ë§ˆì§€ë§‰ ë…¸ë“œë¥¼ êº¼ë‚´ ë°©ë¬¸í•˜ê³ , ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ ë…¸ë“œë¥¼ ë‹¤ì‹œ ìŠ¤íƒì— ì¶”ê°€í•œë‹¤.
   - ì¸ì ‘ ë…¸ë“œëŠ” ì—­ìˆœìœ¼ë¡œ ì¶”ê°€í•˜ì—¬ ì˜¤ë¦„ì°¨ìˆœ ë°©ë¬¸ì„ ìœ ì§€í•œë‹¤.

3. **BFS (ë„ˆë¹„ ìš°ì„  íƒìƒ‰)**
   - íë¥¼ í™œìš©í•˜ì—¬ êµ¬í˜„í•œë‹¤.
   - ë°©ë¬¸í•œ ì •ì ì„ ì²´í¬í•˜ê¸° ìœ„í•´ `map[int]struct{}`ì„ ì‚¬ìš©í•œë‹¤.
   - íì—ì„œ ì²« ë²ˆì§¸ ë…¸ë“œë¥¼ êº¼ë‚´ ë°©ë¬¸í•˜ê³ , ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ ë…¸ë“œë¥¼ ë‹¤ì‹œ íì— ì¶”ê°€í•œë‹¤.

4. **ê²°ê³¼ ì¶œë ¥**
   - DFSì™€ BFS íƒìƒ‰ ê²°ê³¼ë¥¼ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ì—¬ ì¶œë ¥í•œë‹¤.
   - `fmt.Sprint()`ì™€ `strings.Trim()`ì„ í™œìš©í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ í˜•ì‹ì„ ì œê±°í•œë‹¤.

## ì‹œê°„ ë³µìž¡ë„ ë¶„ì„
- **DFSì™€ BFSì˜ ì‹œê°„ ë³µìž¡ë„**: `O(N + M)` (ì •ì ê³¼ ê°„ì„ ì˜ ê°œìˆ˜ì— ë¹„ë¡€)
- `sort.Ints()`ì˜ ì •ë ¬ ë¹„ìš©: `O(N log N)`
- ë”°ë¼ì„œ, ìµœì¢… ì‹œê°„ ë³µìž¡ë„ëŠ” `O(N log N + M)`

## ê²°ë¡ 
ì´ ì½”ë“œëŠ” DFSì™€ BFSë¥¼ ì´ìš©í•˜ì—¬ ì •ì ì„ ë°©ë¬¸í•˜ëŠ” ìˆœì„œë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ë©°, ë°©ë¬¸í•  ìˆ˜ ìžˆëŠ” ë…¸ë“œê°€ ì—¬ëŸ¬ ê°œì¼ ê²½ìš° **ìž‘ì€ ë²ˆí˜¸ë¶€í„° ìš°ì„ ì ìœ¼ë¡œ ë°©ë¬¸í•˜ë„ë¡ ì •ë ¬**í•˜ì—¬ êµ¬í˜„í•˜ì˜€ë‹¤.

