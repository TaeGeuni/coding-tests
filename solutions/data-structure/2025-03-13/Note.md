# KOI 통신연구소 레이저 신호 문제 풀이
👉🏻[문제 링크](https://www.acmicpc.net/problem/2493)

## 문제 설명
KOI 통신연구소에서는 레이저를 이용한 새로운 비밀 통신 시스템을 개발 중입니다. 이를 위해 일직선 위에 높이가 서로 다른 N개의 탑을 왼쪽에서 오른쪽 방향으로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치했습니다.

모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 왼쪽 방향으로 발사합니다. 그리고 모든 탑의 기둥에는 레이저 신호를 수신하는 장치가 있습니다. 한 탑에서 발사된 레이저 신호는 가장 먼저 만나는 하나의 탑에서만 수신됩니다.

## 입력
- 첫째 줄에 탑의 개수를 나타내는 정수 N이 주어집니다. (1 ≤ N ≤ 500,000)
- 둘째 줄에는 N개의 탑들의 높이가 순서대로 주어집니다. (1 ≤ 높이 ≤ 100,000,000)

## 출력
- 각 탑에서 발사한 레이저 신호를 수신한 탑의 번호를 출력합니다. (1부터 시작)
- 만약 레이저 신호를 수신하는 탑이 없으면 0을 출력합니다.

## 예제
### 입력
```
5
6 9 5 7 4
```
### 출력
```
0 0 2 2 4
```

## 해결 방법
이 문제는 **스택 (Stack)** 자료구조를 이용하여 효율적으로 해결할 수 있습니다.

1. **스택 활용:**
   - 각 탑의 인덱스와 높이를 저장하는 스택을 사용합니다.
   - 현재 탑이 이전 탑보다 높으면, 이전 탑들은 현재 탑의 신호를 수신할 수 없으므로 스택에서 제거합니다.
   - 스택에서 제거되지 않고 남아 있는 가장 가까운 탑이 신호를 수신하는 탑이 됩니다.

2. **시간 복잡도:**
   - 모든 요소를 한 번씩만 확인하고 스택에서 추가 및 제거를 수행하므로 O(N) 시간 복잡도로 해결할 수 있습니다.

## 코드 구현 (Golang)
```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

var reader = bufio.NewReader(os.Stdin)
var writer = bufio.NewWriter(os.Stdout)

func ReceiveSignal(tower []int) []int {
	res := make([]int, len(tower))
	stack := make([][2]int, 0) // 스택: (탑의 인덱스, 탑의 높이)

	for i := 0; i < len(tower); i++ {
		// 현재 탑이 이전 탑보다 높으면, 이전 탑 제거
		for len(stack) > 0 && stack[len(stack)-1][1] < tower[i] {
			stack = stack[:len(stack)-1]
		}

		// 신호를 수신하는 탑이 있다면 인덱스를 저장
		if len(stack) > 0 {
			res[i] = stack[len(stack)-1][0] + 1
		} else {
			res[i] = 0
		}

		// 현재 탑을 스택에 추가
		stack = append(stack, [2]int{i, tower[i]})
	}

	return res
}

func main() {
	defer writer.Flush()

	var n int
	fmt.Fscan(reader, &n)

	tower := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &tower[i])
	}

	res := ReceiveSignal(tower)

	for i := 0; i < n; i++ {
		fmt.Fprintf(writer, "%d ", res[i])
	}
}
```

## 코드 설명
1. **입력 처리:**
   - `bufio`를 이용하여 빠르게 입력을 받습니다.
   - 첫 번째 줄에서 `N`을 입력받고, 두 번째 줄에서 탑의 높이를 배열에 저장합니다.

2. **ReceiveSignal 함수:**
   - `res` 배열을 선언하여 각 탑이 신호를 수신하는 탑의 인덱스를 저장합니다.
   - `stack`을 활용하여 이전 탑의 정보를 저장하고 비교합니다.
   - 스택을 활용하여 현재 탑보다 낮은 탑들은 제거하고, 남아있는 탑 중 가장 가까운 탑이 신호를 수신합니다.

3. **출력 처리:**
   - `bufio.Writer`를 사용하여 빠르게 결과를 출력합니다.

## 결론
- **스택을 활용하여 O(N) 시간 복잡도로 해결할 수 있는 문제**입니다.
- **탑들의 높이를 비교하며 스택을 유지하는 방식으로 최적의 성능을 보장**합니다.
- **Golang의 빠른 입출력 방식(`bufio`)을 사용하여 큰 입력에도 대응**할 수 있도록 구현하였습니다.

