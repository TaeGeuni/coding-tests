# 센서 문제 풀이
👉🏻[문제 링크](https://www.acmicpc.net/problem/2212)

## 문제 설명

한국도로공사는 고속도로 위에 N개의 센서를 설치하고, 이를 수집 및 분석하기 위해 최대 K개의 집중국을 세우려고 합니다.

### 요구 사항
- 각 센서는 적어도 하나의 집중국과 통신할 수 있어야 합니다.
- 집중국의 수신 가능 영역의 길이 합을 최소화해야 합니다.

### 입력
1. 첫 줄에 센서의 개수 `N(1 ≤ N ≤ 10,000)`와 집중국의 개수 `K(1 ≤ K ≤ 1000)`
2. 둘째 줄에 `N`개의 센서 좌표 (각 좌표는 정수, 절댓값 ≤ 1,000,000)

### 출력
최소 수신 가능 영역 길이의 합

### 예제 입력
#### 입력 1
```
6
2
1 6 9 3 6 7
```
#### 출력 1
```
5
```

#### 입력 2
```
10
5
20 3 14 6 7 8 18 10 12 15
```
#### 출력 2
```
7
```

---

## 해결 아이디어

### 접근 방법
1. **정렬 후 거리 차이 계산**:
   - 센서 좌표를 오름차순으로 정렬
   - 인접한 센서 간 거리 차이를 계산

2. **거리 차이로 그룹 나누기**:
   - 가장 큰 거리 차이를 K-1개 제거하면, K개의 그룹으로 나뉨

3. **남은 거리 합 계산**:
   - 남은 거리 차이들의 합이 최솟값이 됨

### 알고리즘
1. 센서 좌표를 정렬
2. 거리 차이를 계산하여 배열로 저장
3. 거리 차이 배열을 정렬
4. K-1개의 가장 큰 거리를 제거
5. 남은 거리 차이의 합을 출력

---

## 구현

### 코드
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

var (
	reader = bufio.NewReader(os.Stdin)
	writer = bufio.NewWriter(os.Stdout)
)

func FindMin(k int, sensors []int) int {
	res := 0
	if len(sensors) == 1 {
		return res
	}
	distance := make([]int, 0)

	sort.Ints(sensors)

	for i := 1; i < len(sensors); i++ {
		distance = append(distance, sensors[i]-sensors[i-1])
	}

	sort.Ints(distance)

	if k > 1 {
		distance = distance[:len(distance)-k+1]
	}

	for i := 0; i < len(distance); i++ {
		res += distance[i]
	}

	return res
}

func main() {
	defer writer.Flush()

	var n, k int
	fmt.Fscan(reader, &n)
	fmt.Fscan(reader, &k)

	sensors := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Fscan(reader, &sensors[i])
	}

	fmt.Fprintln(writer, FindMin(k, sensors))
}
```

---

## 실행 과정

### 입력 예제 1
```
6
2
1 6 9 3 6 7
```

#### 실행 단계
1. 센서 정렬: `[1, 3, 6, 6, 7, 9]`
2. 거리 차이 계산: `[2, 3, 0, 1, 2]`
3. 거리 차이 정렬: `[0, 1, 2, 2, 3]`
4. 가장 큰 거리 1개 제거 (K=2): `[0, 1, 2, 2]`
5. 거리 합: `0 + 1 + 2 + 2 = 5`

#### 출력
```
5
```

### 입력 예제 2
```
10
5
20 3 14 6 7 8 18 10 12 15
```

#### 실행 단계
1. 센서 정렬: `[3, 6, 7, 8, 10, 12, 14, 15, 18, 20]`
2. 거리 차이 계산: `[3, 1, 1, 2, 2, 2, 1, 3, 2]`
3. 거리 차이 정렬: `[1, 1, 1, 2, 2, 2, 2, 3, 3]`
4. 가장 큰 거리 4개 제거 (K=5): `[1, 1, 1, 2, 2]`
5. 거리 합: `1 + 1 + 1 + 2 + 2 = 7`

#### 출력
```
7
```

---

## 시간 복잡도

1. **정렬**: O(N log N)
2. **거리 차이 계산**: O(N)
3. **거리 차이 정렬**: O(N log N)
4. **거리 합 계산**: O(N)

총합: **O(N log N)**

---

## 참고

이 풀이는 탐욕법(Greedy)을 활용해 거리 차이를 기반으로 그룹을 나누어 최적의 해를 구했습니다. 문제의 핵심은 정렬과 거리 차이를 적절히 활용하는 것입니다.

