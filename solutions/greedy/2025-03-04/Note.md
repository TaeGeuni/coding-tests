# 문제 해결 과정
👉🏻[문제 링크](https://www.acmicpc.net/problem/1449)

## 문제 설명
항승이는 수도 파이프를 수리하는 기술자로, 물이 새는 곳을 테이프로 막아야 합니다. 물이 새는 위치는 정수 좌표로 주어지며, 길이 L인 테이프를 사용하여 막을 수 있습니다. 테이프는 물이 새는 위치의 좌우 0.5만큼 추가로 덮어야 하며, 최소 개수의 테이프를 사용하여 모든 누수를 막아야 합니다.

## 입력
- 첫 번째 줄: 물이 새는 위치의 개수 `N`과 테이프의 길이 `L`이 주어집니다. (`1 \leq N, L \leq 1000`)
- 두 번째 줄: 물이 새는 위치를 나타내는 `N`개의 정수가 주어집니다. (`1 \leq 위치 \leq 1000`)

## 출력
- 최소 개수의 테이프를 출력합니다.

## 예제 입력 및 출력
### 예제 1
**입력:**
```
4 2
1 2 100 101
```
**출력:**
```
2
```

### 예제 2
**입력:**
```
4 3
1 2 3 4
```
**출력:**
```
2
```

### 예제 3
**입력:**
```
3 1
3 2 1
```
**출력:**
```
3
```

---

# 코드 구현 및 설명

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
)

var reader = bufio.NewReader(os.Stdin)
var writer = bufio.NewWriter(os.Stdout)

func main() {
	defer writer.Flush()

	var N, L, res int
	fmt.Fscan(reader, &N, &L)
	pipe := make([]int, N)

	for i := 0; i < N; i++ {
		fmt.Fscan(reader, &pipe[i])
	}

	// 물이 새는 위치를 정렬
	sort.Slice(pipe, func(i, j int) bool {
		return pipe[i] < pipe[j]
	})

	lastTape := 0 // 마지막으로 붙인 테이프의 끝 위치

	for i := 0; i < N; i++ {
		// 현재 위치가 마지막 테이프의 커버 범위를 벗어나면 새 테이프 사용
		if pipe[i] > lastTape {
			lastTape = pipe[i] + L - 1
			res++
		}
	}

	fmt.Fprintln(writer, res)
}
```

## 코드 설명
1. **입력값을 읽어들입니다.**
2. **물이 새는 위치를 오름차순 정렬합니다.**
3. **그리디 알고리즘을 사용하여 테이프를 최소 개수로 사용합니다.**
   - `lastTape` 변수를 사용하여 마지막 테이프가 덮을 수 있는 최대 위치를 추적합니다.
   - 각 위치를 확인하면서, 현재 테이프가 해당 위치를 덮지 못하면 새로운 테이프를 사용합니다.
   - 테이프를 붙이면, 덮을 수 있는 최대 범위를 갱신합니다.
4. **결과를 출력합니다.**

## 사용한 알고리즘: 그리디 알고리즘
이 문제는 **그리디 알고리즘(Greedy Algorithm)**을 사용하여 해결할 수 있습니다. 그리디 알고리즘은 각 단계에서 최적의 선택을 하는 방법으로, 이 문제에서는 **물이 새는 위치를 정렬한 후, 가장 앞의 위치부터 가능한 최소 개수의 테이프를 붙이는 방식**을 사용합니다. 

## 시간 복잡도 분석
- 정렬: `O(N log N)`
- 탐색: `O(N)`
- 총 시간 복잡도: `O(N log N)`

## 결론
이 방법을 사용하면 최소한의 테이프 개수로 모든 누수를 효과적으로 막을 수 있습니다.

