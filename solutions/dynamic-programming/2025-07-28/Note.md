# 사자 우리 문제 풀이
👉🏻[문제 링크](https://www.acmicpc.net/problem/1309)

## 문제 설명

2 x N 크기의 동물 우리에 사자를 배치하려고 한다. 규칙은 다음과 같다:

- 사자는 어떤 칸에도 놓을 수 있지만, 사자가 가로 또는 세로로 인접해 있으면 안 된다.
- 사자를 한 마리도 배치하지 않는 경우도 하나의 경우로 간주한다.

예를 들어, N = 4일 때 가능한 배치의 수는 41가지이며, 이 수를 9901로 나눈 나머지를 출력해야 한다.

---

## 입력

첫 번째 줄에 정수 N (1 ≤ N ≤ 100,000)이 주어진다.

## 출력

사자를 배치할 수 있는 경우의 수를 9901로 나눈 나머지를 출력한다.

---

## 예제 입력

```
4
```

## 예제 출력

```
41
```

---

## 해결 방법

동적 프로그래밍(DP)을 이용한 문제로, 각 열마다의 상태를 고려하여 점화식을 세운다.

우리는 2 x N 칸에서 각 열마다 가능한 상태를 다음과 같이 나눈다:

- 아무 사자도 배치하지 않는 경우
- 왼쪽 칸에만 사자를 배치한 경우
- 오른쪽 칸에만 사자를 배치한 경우

이 세 가지를 각각 경우의 수로 고려할 수 있다.

### 점화식

- 초기 상태:
  - `dp[0] = 1`
  - `dp[1] = 3` (00, 10, 01)

- 점화식:
  - `dp[i] = dp[i-1]*2 + dp[i-2]`
  - 이유: 이전 열에 아무 사자도 없는 상태에서 두 경우(왼쪽, 오른쪽)에 추가하거나, i-2 위치에서 두 열을 건너뛰어 올 수 있다.

- 이 수를 9901로 나눈 나머지를 출력해야 한다.

---

## 구현 코드 (Go)

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

var (
    reader = bufio.NewReader(os.Stdin)
    writer = bufio.NewWriter(os.Stdout)
)

func lionCage(n int) int {
    prev := 1
    now := 3
    res := 3

    for i := 1; i < n; i++ {
        res = res*2 + prev
        prev = now
        now = res

        res = res % 9901
    }

    return res
}

func main() {
    defer writer.Flush()
    n := 0
    fmt.Fscan(reader, &n)

    fmt.Fprintln(writer, lionCage(n))
}
```

이 코드는 O(N) 시간 복잡도로 주어진 조건을 만족하는 사자 배치의 수를 효율적으로 계산할 수 있다.
