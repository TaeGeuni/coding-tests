# RGB ê±°ë¦¬ ë¬¸ì œ í’€ì´
ğŸ‘‰ğŸ»[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/1149)

## ë¬¸ì œ ì„¤ëª…
RGBê±°ë¦¬ì—ëŠ” ì§‘ì´ Nê°œ ìˆë‹¤. ì§‘ì€ ë¹¨ê°•, ì´ˆë¡, íŒŒë‘ ì¤‘ í•˜ë‚˜ì˜ ìƒ‰ìœ¼ë¡œ ì¹ í•´ì•¼ í•˜ë©°, ì•„ë˜ ê·œì¹™ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤.

1. 1ë²ˆ ì§‘ì˜ ìƒ‰ì€ 2ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
2. Në²ˆ ì§‘ì˜ ìƒ‰ì€ N-1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.
3. i(2 â‰¤ i â‰¤ N-1)ë²ˆ ì§‘ì˜ ìƒ‰ì€ i-1ë²ˆ, i+1ë²ˆ ì§‘ì˜ ìƒ‰ê³¼ ê°™ì§€ ì•Šì•„ì•¼ í•œë‹¤.

ê° ì§‘ì„ ì¹ í•˜ëŠ” ë¹„ìš©ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ëª¨ë“  ì§‘ì„ ì¹ í•˜ëŠ” ë¹„ìš©ì˜ ìµœì†Ÿê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

## ì…ë ¥
ì²«ì§¸ ì¤„ì— ì§‘ì˜ ìˆ˜ N(2 â‰¤ N â‰¤ 1,000)ì´ ì£¼ì–´ì§„ë‹¤.
ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì—ëŠ” ê° ì§‘ì„ ë¹¨ê°•, ì´ˆë¡, íŒŒë‘ìœ¼ë¡œ ì¹ í•˜ëŠ” ë¹„ìš©ì´ ì£¼ì–´ì§„ë‹¤. ë¹„ìš©ì€ 1,000 ì´í•˜ì˜ ìì—°ìˆ˜ì´ë‹¤.

## ì¶œë ¥
ëª¨ë“  ì§‘ì„ ì¹ í•˜ëŠ” ë¹„ìš©ì˜ ìµœì†Ÿê°’ì„ ì¶œë ¥í•œë‹¤.

## ì˜ˆì œ ì…ë ¥ ë° ì¶œë ¥
### ì˜ˆì œ ì…ë ¥ 1
```
3
26 40 83
49 60 57
13 89 99
```
### ì˜ˆì œ ì¶œë ¥ 1
```
96
```

### ì˜ˆì œ ì…ë ¥ 2
```
3
1 100 100
100 1 100
100 100 1
```
### ì˜ˆì œ ì¶œë ¥ 2
```
3
```

## í’€ì´ ê³¼ì •
ì´ ë¬¸ì œëŠ” ë™ì  ê³„íšë²•(DP)ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

1. `cost[i][0]`, `cost[i][1]`, `cost[i][2]`ëŠ” ê°ê° ië²ˆì§¸ ì§‘ì„ ë¹¨ê°•, ì´ˆë¡, íŒŒë‘ìœ¼ë¡œ ì¹ í•˜ëŠ” ë¹„ìš©ì„ ì˜ë¯¸í•œë‹¤.
2. `dp[i][0]`, `dp[i][1]`, `dp[i][2]`ëŠ” ië²ˆì§¸ ì§‘ì„ í•´ë‹¹ ìƒ‰ìœ¼ë¡œ ì¹ í–ˆì„ ë•Œì˜ ìµœì†Œ ë¹„ìš©ì„ ì €ì¥í•œë‹¤.
3. ì í™”ì‹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:
   - `dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + cost[i][0]`
   - `dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + cost[i][1]`
   - `dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + cost[i][2]`
4. ë§ˆì§€ë§‰ ì§‘ì—ì„œ ìµœì†Œê°’ì„ ì¶œë ¥í•˜ë©´ ëœë‹¤.

## ì½”ë“œ êµ¬í˜„ (Golang)
```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

var reader = bufio.NewReader(os.Stdin)
var writer = bufio.NewWriter(os.Stdout)

func Minimum(a, b int) int {
	if a > b {
		return b
	}
	return a
}

func main() {
	defer writer.Flush()

	var num int
	fmt.Fscan(reader, &num)
	cost := make([][3]int, num)

	for i := 0; i < num; i++ {
		var r, g, b int
		fmt.Fscan(reader, &r, &g, &b)
		cost[i][0], cost[i][1], cost[i][2] = r, g, b
	}
	dp := make([][3]int, num)
	dp[0][0], dp[0][1], dp[0][2] = cost[0][0], cost[0][1], cost[0][2]

	for i := 1; i < num; i++ {
		dp[i][0] = Minimum(dp[i-1][1], dp[i-1][2]) + cost[i][0]
		dp[i][1] = Minimum(dp[i-1][0], dp[i-1][2]) + cost[i][1]
		dp[i][2] = Minimum(dp[i-1][0], dp[i-1][1]) + cost[i][2]
	}
	res := Minimum(dp[num-1][0], dp[num-1][1])
	res = Minimum(res, dp[num-1][2])

	fmt.Fprintln(writer, res)
}
```

## ì‹œê°„ ë³µì¡ë„
ì´ ì½”ë“œëŠ” O(N)ìœ¼ë¡œ ë™ì‘í•˜ë©°, ê° ì§‘ì— ëŒ€í•´ 3ê°€ì§€ ìƒ‰ìƒ ì„ íƒì— ëŒ€í•œ ìµœì†Œ ë¹„ìš©ì„ ê³„ì‚°í•˜ëŠ” ë°©ì‹ì´ë‹¤. `N â‰¤ 1,000`ì´ë¯€ë¡œ ì¶©ë¶„íˆ ë¹ ë¥´ê²Œ ì‹¤í–‰ëœë‹¤.

